{"version":3,"sources":["pages/Results/index.jsx"],"names":["Results","questions","leaderboardLatest","history","loadQuestions","loadQuestionsFromAPI","deleteQuestionsFromMemory","loadLatestPlayer","saveScore","onRetry","useState","isLoading","setLoading","name","setName","useEffect","Promise","all","length","resolve","then","centered","show","Body","answersCorrect","filter","q","userAnswer","correctAnswer","retry","a","save","push","keyboard","backdrop","Header","Title","Group","Label","Control","value","onChange","event","target","Footer","variant","onClick","defaultProps","withRouter","connect","state","leaderboard","latest","dispatch","questionsActions","leaderboardActions","payload"],"mappings":"oQA0BA,SAASA,EAAT,GAcI,IAAD,EAbDC,EAaC,EAbDA,UACAC,EAYC,EAZDA,kBAEAC,EAUC,EAVDA,QAEAC,EAQC,EARDA,cACAC,EAOC,EAPDA,qBACAC,EAMC,EANDA,0BAEAC,EAIC,EAJDA,iBACAC,EAGC,EAHDA,UAEAC,EACC,EADDA,QACC,EAC+BC,oBAAS,GADxC,mBACMC,EADN,KACiBC,EADjB,OAEuBF,mBAAQ,UAACR,EAAkBW,YAAnB,QAA2B,IAF1D,mBAEMA,EAFN,KAEYC,EAFZ,KAkBD,GAdAC,qBAAU,WACRH,GAAW,GACXI,QAAQC,IAAI,CACVhB,EAAUiB,OAAS,EAAId,IAAkBY,QAAQG,UACjDZ,MACCa,MAAK,WACNR,GAAW,QAEZ,IAEHG,qBAAU,WACRD,EAAQZ,EAAkBW,QACzB,CAACX,EAAkBW,OAElBF,EACF,OACE,cAAC,IAAD,CAAOU,UAAQ,EAACC,MAAI,EAApB,SACE,cAAC,IAAMC,KAAP,2BAON,IAAMC,EAAiBvB,EAAUwB,QAAO,SAACC,GAAD,OAAOA,EAAEC,aAAeD,EAAEE,iBAAeV,OAE3EW,EAAK,uCAAG,sBAAAC,EAAA,6DACZlB,GAAW,GADC,SAENP,IAFM,OAGZC,IACAG,IAJY,2CAAH,qDAOLsB,EAAI,uCAAG,sBAAAD,EAAA,sEACLtB,EAAU,CACdK,OACAW,mBAHS,OAMXrB,EAAQ6B,KAAK,gBANF,2CAAH,qDASV,OACE,eAAC,IAAD,CAAOX,UAAQ,EAACC,MAAI,EAACW,UAAU,EAAOC,SAAS,SAA/C,UACE,cAAC,IAAMC,OAAP,UACE,cAAC,IAAMC,MAAP,iCACmBZ,EADnB,YACqCvB,EAAUiB,YAGjD,eAAC,IAAMK,KAAP,WACE,iEAGA,eAAC,IAAKc,MAAN,WACE,cAAC,IAAKC,MAAN,yBACA,cAAC,IAAKC,QAAN,CAAcC,MAAO3B,EAAM4B,SAAU,SAACC,GAAD,OAAW5B,EAAQ4B,EAAMC,OAAOH,gBAGzE,eAAC,IAAMI,OAAP,WACE,cAAC,IAAD,CAAQC,QAAQ,kBAAkBC,QAASjB,EAA3C,uBACA,cAAC,IAAD,CAAQgB,QAAQ,UAAUC,QAASf,EAAnC,wBA8BR/B,EAAQ+C,aAAe,CACrBtC,QAAS,cAiBIuC,sBAAWC,aAdF,SAACC,GAAD,MAAY,CAClCjD,UAAWiD,EAAMjD,UAAUA,UAC3BC,kBAAmBgD,EAAMC,YAAYC,WAGZ,SAACC,GAAD,MAAe,CACxCjD,cAAe,kBAAMiD,EAASC,QAC9BhD,0BAA2B,kBAAM+C,EAASC,QAC1CjD,qBAAsB,kBAAMgD,EAASC,QAErC/C,iBAAkB,kBAAM8C,EAASE,QACjC/C,UAAW,SAACgD,GAAD,OAAaH,EAASE,IAA6BC,QAGtCP,CAA6CjD","file":"static/js/8.5cdff698.chunk.js","sourcesContent":["import React, { useEffect, useState } from \"react\";\nimport { withRouter } from \"react-router\";\nimport { connect } from \"react-redux\";\nimport PropTypes from \"prop-types\";\nimport {\n  Button, Form, Modal,\n} from \"react-bootstrap\";\nimport * as questionsActions from \"../../store/questions/actions\";\nimport * as leaderboardActions from \"../../store/leaderboard/actions\";\nimport \"./index.scss\";\n\n/**\n * Modal for the game results\n *\n * @param {Question[]} questions\n * @param {Object} leaderboardLatest\n * @param {History} history\n * @param {Function} loadQuestions\n * @param {Function} loadQuestionsFromAPI\n * @param {Function} deleteQuestionsFromMemory\n * @param {Function} loadLatestPlayer\n * @param {Function} saveScore\n * @param {Function} onRetry\n * @returns {JSX.Element}\n * @constructor\n */\nfunction Results({\n  questions,\n  leaderboardLatest,\n\n  history,\n\n  loadQuestions,\n  loadQuestionsFromAPI,\n  deleteQuestionsFromMemory,\n\n  loadLatestPlayer,\n  saveScore,\n\n  onRetry,\n}) {\n  const [isLoading, setLoading] = useState(false);\n  const [name, setName] = useState(leaderboardLatest.name ?? \"\");\n\n  useEffect(() => {\n    setLoading(true);\n    Promise.all([\n      questions.length < 1 ? loadQuestions() : Promise.resolve(),\n      loadLatestPlayer(),\n    ]).then(() => {\n      setLoading(false);\n    });\n  }, []);\n\n  useEffect(() => {\n    setName(leaderboardLatest.name);\n  }, [leaderboardLatest.name]);\n\n  if (isLoading) {\n    return (\n      <Modal centered show>\n        <Modal.Body>\n          Loading...\n        </Modal.Body>\n      </Modal>\n    );\n  }\n\n  const answersCorrect = questions.filter((q) => q.userAnswer === q.correctAnswer).length;\n\n  const retry = async () => {\n    setLoading(true);\n    await loadQuestionsFromAPI();\n    deleteQuestionsFromMemory();\n    onRetry();\n  };\n\n  const save = async () => {\n    await saveScore({\n      name,\n      answersCorrect,\n    });\n\n    history.push(\"/leaderboard\");\n  };\n\n  return (\n    <Modal centered show keyboard={false} backdrop=\"static\">\n      <Modal.Header>\n        <Modal.Title>\n          {`You answered ${answersCorrect}/${questions.length}`}\n        </Modal.Title>\n      </Modal.Header>\n      <Modal.Body>\n        <p>\n          Do you want to save your result?\n        </p>\n        <Form.Group>\n          <Form.Label>Your name:</Form.Label>\n          <Form.Control value={name} onChange={(event) => setName(event.target.value)} />\n        </Form.Group>\n      </Modal.Body>\n      <Modal.Footer>\n        <Button variant=\"outline-primary\" onClick={retry}>Try again</Button>\n        <Button variant=\"primary\" onClick={save}>Save</Button>\n      </Modal.Footer>\n    </Modal>\n  );\n}\n\nResults.propTypes = {\n  loadQuestions: PropTypes.func.isRequired,\n  loadQuestionsFromAPI: PropTypes.func.isRequired,\n  deleteQuestionsFromMemory: PropTypes.func.isRequired,\n\n  loadLatestPlayer: PropTypes.func.isRequired,\n  saveScore: PropTypes.func.isRequired,\n\n  onRetry: PropTypes.func,\n\n  leaderboardLatest: PropTypes.shape({\n    name: PropTypes.string,\n  }).isRequired,\n\n  questions: PropTypes.arrayOf(PropTypes.shape({\n    id: PropTypes.number,\n  })).isRequired,\n\n  history: PropTypes.shape({\n    replace: PropTypes.func,\n    push: PropTypes.func,\n  }).isRequired,\n};\n\nResults.defaultProps = {\n  onRetry: () => {},\n};\n\nconst mapStateToProps = (state) => ({\n  questions: state.questions.questions,\n  leaderboardLatest: state.leaderboard.latest,\n});\n\nconst mapDispatchToProps = (dispatch) => ({\n  loadQuestions: () => dispatch(questionsActions.loadQuestionsFromDB()),\n  deleteQuestionsFromMemory: () => dispatch(questionsActions.deleteQuestionsFromMemory()),\n  loadQuestionsFromAPI: () => dispatch(questionsActions.loadQuestionsFromAPI()),\n\n  loadLatestPlayer: () => dispatch(leaderboardActions.loadLatestPlayer()),\n  saveScore: (payload) => dispatch(leaderboardActions.saveScore(payload)),\n});\n\nexport default withRouter(connect(mapStateToProps, mapDispatchToProps)(Results));\n"],"sourceRoot":""}