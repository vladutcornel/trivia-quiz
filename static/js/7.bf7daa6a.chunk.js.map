{"version":3,"sources":["pages/Questions/Question/index.jsx","components/Countdown/index.jsx","pages/Questions/index.jsx"],"names":["Question","question","showAnswer","saveAnswer","questionNumber","Card","Header","Body","ListGroup","className","answers","map","answer","index","Item","onClick","Form","Check","id","name","value","type","label","isValid","correctAnswer","isInvalid","checked","userAnswer","onChange","defaultProps","connect","dispatch","answerIndex","questions","Countdown","until","onTimeout","calculateTimeLeft","diff","Date","now","seconds","Math","floor","minutes","useState","timeLeft","setTimeLeft","useEffect","setTimeout","oldDiff","newTimeLeft","String","padStart","Results","React","lazy","withRouter","state","expireTime","expire","loadQuestions","questionsActions","amount","match","history","isLoading","setLoading","showResults","setShowResults","length","then","params","Alert","nextIcon","currentQuestionNumber","parseInt","answeredCount","filter","q","createElement","Button","disabled","event","stopPropagation","prevIcon","undefined","Container","Carousel","activeIndex","interval","onSelect","replace","prevLabel","nextLabel","wrap","touch","onSlide","fallback","Modal","onRetry","push"],"mappings":"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","file":"static/js/7.bf7daa6a.chunk.js","sourcesContent":["import React from \"react\";\nimport PropTypes from \"prop-types\";\nimport { Card, Form, ListGroup } from \"react-bootstrap\";\nimport { connect } from \"react-redux\";\nimport * as questions from \"../../../store/questions/actions\";\n\nfunction Question({\n  question, showAnswer, saveAnswer, questionNumber,\n}) {\n  return (\n    <Card>\n      <Card.Header>\n        Question\n        {questionNumber ? ` ${questionNumber}` : \"\"}\n      </Card.Header>\n      <Card.Body>\n        <p>\n          {question.question}\n        </p>\n      </Card.Body>\n      <ListGroup className=\"list-group-flush\">\n        {question.answers.map((answer, index) => (\n          <ListGroup.Item\n            key={answer}\n            onClick={() => saveAnswer(question, index)}\n          >\n            <Form.Check\n              id={`answer${question.id}-${index}`}\n              name={`answer${question.id}`}\n              value={index}\n              type=\"radio\"\n              label={answer}\n              isValid={showAnswer && index === question.correctAnswer}\n              isInvalid={showAnswer && index !== question.correctAnswer}\n              checked={question.userAnswer === index}\n              onChange={() => saveAnswer(question, index)}\n            />\n          </ListGroup.Item>\n        ))}\n      </ListGroup>\n    </Card>\n  );\n}\n\nQuestion.propTypes = {\n  questionNumber: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),\n  showAnswer: PropTypes.bool,\n  saveAnswer: PropTypes.func,\n\n  question: PropTypes.shape({\n    id: PropTypes.number,\n    type: PropTypes.string,\n    question: PropTypes.string,\n    answers: PropTypes.arrayOf(PropTypes.string),\n    correctAnswer: PropTypes.number,\n    userAnswer: PropTypes.number,\n  }).isRequired,\n};\n\nQuestion.defaultProps = {\n  questionNumber: 0,\n  showAnswer: false,\n  saveAnswer: () => {},\n};\n\nconst mapDispatchToProps = (dispatch) => ({\n  saveAnswer: (question, answerIndex) => dispatch(questions.saveAnswer({ question, answerIndex })),\n});\n\nexport default connect(null, mapDispatchToProps)(Question);\n","import React, { useEffect, useState } from \"react\";\nimport PropTypes from \"prop-types\";\n\n/**\n * Component that renders a countdown in minutes and seconds, until the provided\n *\n * @param {Number} until timestamp when the countdown should reach 0\n * @param {Function} onTimeout Event fired when 0 is reached\n * @returns {JSX.Element}\n * @constructor\n */\nfunction Countdown({ until, onTimeout }) {\n  const calculateTimeLeft = () => {\n    const diff = until - Date.now();\n    const seconds = Math.floor(diff / 1e3);\n    const minutes = Math.floor(seconds / 60);\n\n    return {\n      diff,\n      seconds: seconds % 60,\n      minutes: minutes % 60,\n    };\n  };\n\n  const [timeLeft, setTimeLeft] = useState(calculateTimeLeft());\n\n  useEffect(() => {\n    setTimeout(() => {\n      const oldDiff = timeLeft.diff;\n      const newTimeLeft = calculateTimeLeft();\n\n      if (oldDiff > 0 && newTimeLeft.diff <= 0) {\n        onTimeout();\n      } else {\n        setTimeLeft(newTimeLeft);\n      }\n    }, 1e3);\n  });\n\n  if (timeLeft.diff < 0) {\n    return (<span />);\n  }\n\n  return (\n    <>{`${timeLeft.minutes}:${String(timeLeft.seconds).padStart(2, \"0\")}`}</>\n  );\n}\n\nCountdown.propTypes = {\n  until: PropTypes.number.isRequired,\n  onTimeout: PropTypes.func,\n};\n\nCountdown.defaultProps = {\n  onTimeout: () => {},\n};\n\nexport default Countdown;\n","import React, { useEffect, useState, Suspense } from \"react\";\nimport PropTypes from \"prop-types\";\nimport { withRouter } from \"react-router\";\nimport {\n  Alert, Button, Carousel, Container, Modal,\n} from \"react-bootstrap\";\nimport { connect } from \"react-redux\";\n\nimport * as questionsActions from \"../../store/questions/actions\";\nimport Question from \"./Question\";\n\nimport \"./index.scss\";\nimport Countdown from \"../../components/Countdown\";\n\nconst Results = React.lazy(() => import(\"../Results\"));\n\n/**\n * Page to answer the trivia quiz\n *\n * @param loadQuestions\n * @param questions\n * @param expireTime\n * @param match\n * @param history\n * @returns {JSX.Element|boolean}\n * @constructor\n */\nfunction Questions({\n  loadQuestions,\n  questions,\n  expireTime,\n  match,\n  history,\n}) {\n  const [isLoading, setLoading] = useState(false);\n  const [showResults, setShowResults] = useState(false);\n  useEffect(() => {\n    if (questions.length < 1) {\n      setLoading(true);\n      loadQuestions().then(() => {\n        setLoading(false);\n      });\n    }\n  }, [match.params.question]);\n\n  if (isLoading) {\n    return <Alert>Loading...</Alert>;\n  }\n\n  const updateSlide = (index) => {\n    if (index < questions.length) {\n      history.replace(`/q/${index + 1}`);\n    }\n  };\n\n  const currentQuestionNumber = parseInt(match.params.question, 10);\n\n  const answeredCount = questions.filter((q) => q.userAnswer >= 0).length;\n\n  const retry = () => {\n    history.push(\"/q/1\");\n    setShowResults(false);\n  };\n\n  let nextIcon;\n  if (currentQuestionNumber === questions.length) {\n    nextIcon = React.createElement(Button, {\n      disabled: answeredCount !== questions.length,\n      onClick(event) {\n        event.stopPropagation();\n        setShowResults(true);\n        return false;\n      },\n    }, \"Submit\");\n  }\n  const prevIcon = currentQuestionNumber === 1 ? null : undefined;\n\n  return (\n    <Container className=\"Questions\">\n      <div className=\"countdown\">\n        {showResults ? null : (\n          <Countdown until={expireTime} onTimeout={() => setShowResults(true)} />\n        )}\n      </div>\n      <Carousel\n        activeIndex={currentQuestionNumber - 1}\n        interval={null}\n        onSelect={updateSlide}\n        prevLabel=\"Previous question\"\n        nextLabel=\"Next question\"\n        prevIcon={prevIcon}\n        nextIcon={nextIcon}\n        wrap\n        touch={false}\n        onSlide={() => false}\n      >\n        {questions.map((question, index) => (\n          <Carousel.Item key={question.id}>\n            <Question\n              question={question}\n              questionNumber={`${index + 1} of ${questions.length}`}\n            />\n          </Carousel.Item>\n        ))}\n      </Carousel>\n      {!showResults ? null : (\n        <Suspense fallback={<Modal>Loading...</Modal>}>\n          <Results onRetry={retry} />\n        </Suspense>\n      )}\n    </Container>\n  );\n}\n\nQuestions.propTypes = {\n  loadQuestions: PropTypes.func.isRequired,\n  expireTime: PropTypes.number.isRequired,\n\n  questions: PropTypes.arrayOf(PropTypes.shape({\n    id: PropTypes.number,\n  })).isRequired,\n\n  match: PropTypes.shape({\n    params: PropTypes.shape({\n      question: PropTypes.string,\n    }),\n  }).isRequired,\n\n  history: PropTypes.shape({\n    replace: PropTypes.func,\n    push: PropTypes.func,\n  }).isRequired,\n};\n\nconst mapStateToProps = (state) => ({\n  questions: state.questions.questions,\n  expireTime: state.questions.expire,\n});\n\nconst mapDispatchToProps = (dispatch) => ({\n  loadQuestions: () => dispatch(questionsActions.loadQuestionsFromDB({ amount: 10 })),\n});\n\nexport default withRouter(connect(mapStateToProps, mapDispatchToProps)(Questions));\n"],"sourceRoot":""}